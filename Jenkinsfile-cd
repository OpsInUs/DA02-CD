pipeline {
    agent any
    parameters {
        string(name: 'ADMIN_SERVER_BRANCH', defaultValue: 'main', description: 'Branch for spring-petclinic-admin-server')
        string(name: 'API_GATEWAY_BRANCH', defaultValue: 'main', description: 'Branch for spring-petclinic-api-gateway')
        string(name: 'CONFIG_SERVER_BRANCH', defaultValue: 'main', description: 'Branch for spring-petclinic-config-server')
        string(name: 'CUSTOMERS_SERVICE_BRANCH', defaultValue: 'main', description: 'Branch for spring-petclinic-customers-service')
        string(name: 'DISCOVERY_SERVER_BRANCH', defaultValue: 'main', description: 'Branch for spring-petclinic-discovery-server')
        string(name: 'GENAI_SERVICE_BRANCH', defaultValue: 'main', description: 'Branch for spring-petclinic-genai-service')
        string(name: 'VETS_SERVICE_BRANCH', defaultValue: 'main', description: 'Branch for spring-petclinic-vets-service')
        string(name: 'VISITS_SERVICE_BRANCH', defaultValue: 'main', description: 'Branch for spring-petclinic-visits-service')
    }
    environment {
        HELM_RELEASE_NAME = 'petclinic'
        HELM_CHART_DIR_NAME = 'DA02-HelmRepo'
        HELM_REPO_HTTPS_URL = 'https://github.com/OpsInUs/DA02-HelmRepo.git'
        DOCKER_REGISTRY_USERNAME = 'vuhoabinhthachhoa'
        KUBE_CONTEXT = 'gke_thanh-devops_us-central1-a_petclinic'
        TARGET_NAMESPACE = 'dev-review'

        // Define your GCP and WIF details
        GCP_PROJECT_ID        = 'thanh-devops'
        GCP_PROJECT_NUMBER    = '321371933596'
        WIF_POOL_ID           = 'jenkins-oidc-pool'
        WIF_PROVIDER_ID       = 'jenkins-provider'
        GCP_SERVICE_ACCOUNT   = 'jenkins-wif-executor-sa@thanh-devops.iam.gserviceaccount.com'
        JENKINS_OIDC_CRED_ID  = 'jenkins-gcp-oidc-token'

        // Construct the Audience for the WIF credential file
        GCP_WIF_AUDIENCE      = "//iam.googleapis.com/projects/${GCP_PROJECT_NUMBER}/locations/global/workloadIdentityPools/${WIF_POOL_ID}/providers/${WIF_PROVIDER_ID}"
    }
    stages {
        stage('Clone Helm Repository via HTTPS') {
            steps {
                checkout([
                    $class: 'GitSCM',
                    branches: [[name: '*/main']],
                    userRemoteConfigs: [[url: HELM_REPO_HTTPS_URL]],
                    extensions: [[$class: 'RelativeTargetDirectory', relativeTargetDir: HELM_CHART_DIR_NAME]]
                ])
            }
        }

        stage('Verify Tools') {
            steps {
                sh 'echo "PATH: $PATH"'
                sh 'which gcloud || echo "gcloud not found"'
                sh 'which git || echo "git not found"'
                sh 'which helm || echo "helm not found"'
                sh 'which docker || echo "docker not found"'
                sh 'which kubectl || echo "kubectl not found"'
                sh 'which gke-gcloud-auth-plugin || echo "gke-gcloud-auth-plugin not found"'
            }
        }
        
        stage('Deploy to Kubernetes using WIF') {
            steps {
                withCredentials([
                    file(variable: 'ID_TOKEN_FILE_VAR', credentialsId: JENKINS_OIDC_CRED_ID), // Renamed to avoid direct interpolation issues if possible
                    file(credentialsId: 'kubeconfig', variable: 'KUBECONFIG_FILE_PATH')
                ]) {
                    script {
                        // Assign to a local Groovy variable to handle potential interpolation warnings more easily
                        def idTokenFilePath = ID_TOKEN_FILE_VAR 

                        echo "Jenkins OIDC Token file path is in ID_TOKEN_FILE_VAR variable."
                        echo "Target GCP Audience for WIF config: ${GCP_WIF_AUDIENCE}"
                        echo "Service Account to impersonate: ${GCP_SERVICE_ACCOUNT}"

                        // Escape backslashes in file paths for JSON, especially if Jenkins might run on Windows agents
                        def jsonSafeIdTokenPath = idTokenFilePath.replace('\\', '\\\\')

                        def wifCredsJson = """
                        {
                          "type": "external_account",
                          "audience": "${GCP_WIF_AUDIENCE}",
                          "subject_token_type": "urn:ietf:params:oauth:token-type:jwt",
                          "token_url": "https://sts.googleapis.com/v1/token",
                          "service_account_impersonation_url": "https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/${GCP_SERVICE_ACCOUNT}:generateAccessToken",
                          "credential_source": {
                            "file": "${jsonSafeIdTokenPath}",
                            "format": {
                              "type": "text"
                            }
                          }
                        }
                        """
                        def wifConfigFileInWorkspace = "${WORKSPACE}/gcp_oidc_wif_config.json"
                        writeFile file: wifConfigFileInWorkspace, text: wifCredsJson
                        echo "Generated WIF config file at: ${wifConfigFileInWorkspace}"

                        def tempGcloudConfigDir = "${WORKSPACE}/.gcloud_temp_config_jenkins_oidc_deploy"

                        sh """
                            export CLOUDSDK_CONFIG=${tempGcloudConfigDir}
                            mkdir -p \${CLOUDSDK_CONFIG}
                            echo "Using temporary gcloud config directory: \${CLOUDSDK_CONFIG}"

                            echo "Attempting gcloud login using WIF credential file..."
                            gcloud auth login --brief --cred-file=${wifConfigFileInWorkspace} --quiet

                            echo "--- gcloud auth list (after WIF login) ---"
                            gcloud auth list
                            echo "------------------------------------------"
                            
                            echo "Successfully authenticated with GCP for deployment (default project not set in gcloud config for this session)!"
                            echo "Running an example GCP command (listing GKE clusters, explicitly providing project ${GCP_PROJECT_ID})..."
                            gcloud container clusters list --project=${GCP_PROJECT_ID} || echo "Failed to list GKE clusters. Check command, permissions, and ensure issuer is reachable."
                        """
                        // End of WIF Authentication specific script block

                        // --- Start of your original deployment logic ---
                        env.KUBECONFIG = KUBECONFIG_FILE_PATH 

                        echo "Using Kubeconfig from Jenkins credentials. Path is stored in KUBECONFIG_FILE_PATH."
                        sh 'echo "Kubeconfig content (first 10 lines):"; head -n 10 $KUBECONFIG'
                        sh 'kubectl version --client && kubectl version' // Check client and attempt server connection

                        def servicesToUpdate = [
                            'admin-server': params.ADMIN_SERVER_BRANCH,
                            'api-gateway': params.API_GATEWAY_BRANCH,
                            'config-server': params.CONFIG_SERVER_BRANCH,
                            'customers-service': params.CUSTOMERS_SERVICE_BRANCH,
                            'discovery-server': params.DISCOVERY_SERVER_BRANCH,
                            'genai-service': params.GENAI_SERVICE_BRANCH,
                            'vets-service': params.VETS_SERVICE_BRANCH,
                            'visits-service': params.VISITS_SERVICE_BRANCH
                        ]
                        def helmSetArgs = []
                        def servicesWithNodePort = []

                        servicesToUpdate.each { serviceName, branch ->
                            if (branch != 'main') {
                                echo "Processing ${serviceName} with branch ${branch}"
                                
                                def commitHashCmd = "git ls-remote https://github.com/OpsInUs/DA02-CD refs/heads/${branch} | head -1 | cut -f1"
                                def commitHash = sh(script: commitHashCmd, returnStdout: true).trim()

                                if (!commitHash) {
                                    error "Failed to get commit hash for branch '${branch}' for service '${serviceName}'. Branch might not exist or repo is private."
                                }
                                def tag = commitHash.substring(0, 7)
                                def imageName = "spring-petclinic-${serviceName}" 
                                
                                helmSetArgs.add("--set services.${serviceName}.image.repository=${DOCKER_REGISTRY_USERNAME}/${imageName}")
                                helmSetArgs.add("--set services.${serviceName}.image.tag=${tag}")
                                
                                if (serviceName == 'vets-service') { 
                                    helmSetArgs.add("--set services.${serviceName}.serviceType=NodePort")
                                    servicesWithNodePort.add(serviceName)
                                }
                            }
                        }
                        
                        def chartPath = "./${HELM_CHART_DIR_NAME}" 
                        helmSetArgs.add("--set global.namespace=${TARGET_NAMESPACE}")
                        if (helmSetArgs.size() == 1 && helmSetArgs[0] == "--set global.namespace=${TARGET_NAMESPACE}") {
                             echo "No specific service branches provided. Deploying with chart defaults for namespace ${TARGET_NAMESPACE}."
                        }
                        
                        sh "helm dependency update ${chartPath}"

                        def helmCommand = "helm upgrade --install ${HELM_RELEASE_NAME} ${chartPath} --namespace ${TARGET_NAMESPACE} --kube-context ${KUBE_CONTEXT}"
                        if (!helmSetArgs.isEmpty()) {
                            helmCommand += " " + helmSetArgs.join(" ")
                        }
                        
                        sh helmCommand

                        if (!servicesWithNodePort.isEmpty()) {
                            echo "Deployment completed. For services set to NodePort, use the following endpoints to test:"
                            servicesWithNodePort.each { service ->
                                def servicePortForJsonPath = (service == 'vets-service') ? "8083" : "" 
                                def nodePortJsonPath = ""
                                if (servicePortForJsonPath) {
                                    nodePortJsonPath = "{.spec.ports[?(@.port==${servicePortForJsonPath})].nodePort}"
                                } else {
                                    nodePortJsonPath = "{.spec.ports[0].nodePort}"
                                }

                                def nodePort = sh(script: "kubectl get service ${service} -n ${TARGET_NAMESPACE} -o jsonpath='${nodePortJsonPath}' --context ${KUBE_CONTEXT}", returnStdout: true).trim()
                                if (nodePort) {
                                    def nodeIp = sh(script: "kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type==\"ExternalIP\")].address}' --context ${KUBE_CONTEXT}", returnStdout: true).trim()
                                    if (!nodeIp) {
                                        nodeIp = sh(script: "kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type==\"InternalIP\")].address}' --context ${KUBE_CONTEXT}", returnStdout: true).trim()
                                    }
                                    if (nodeIp) {
                                        echo "Service: ${service} - Endpoint: http://${nodeIp}:${nodePort}"
                                    } else {
                                        echo "Service: ${service} - NodePort ${nodePort}. No node IP available. Check GKE node configuration."
                                    }
                                } else {
                                    echo "Service: ${service} - Failed to get NodePort. Ensure chart sets type to NodePort and cluster allows dynamic NodePort allocation."
                                }
                            }
                        }
                        // --- End of your original deployment logic ---
                        
                        sh """
                            echo "Cleaning up WIF temporary files from deploy stage..."
                            rm -f ${wifConfigFileInWorkspace}
                            rm -rf ${tempGcloudConfigDir}
                        """
                    }
                }
            }
        }
    }
    post {
        always {
            // General cleanup
            dir(HELM_CHART_DIR_NAME) { 
                sh "echo 'Cleaning up ${HELM_CHART_DIR_NAME}' && rm -rf ." 
            }
            // Additional cleanup for WIF files if not caught in the stage
            script {
                def wifConfigFileInWorkspace = "${WORKSPACE}/gcp_oidc_wif_config.json"
                if (fileExists(wifConfigFileInWorkspace)) {
                    echo "Post-build: Cleaning up WIF config file: ${wifConfigFileInWorkspace}"
                    sh "rm -f ${wifConfigFileInWorkspace}"
                }
                def tempGcloudConfigDir = "${WORKSPACE}/.gcloud_temp_config_jenkins_oidc_deploy"
                 if (fileExists(tempGcloudConfigDir)) {
                    echo "Post-build: Cleaning up temporary gcloud config directory: ${tempGcloudConfigDir}"
                    sh "rm -rf ${tempGcloudConfigDir}"
                }
            }
        }
    }
}
