pipeline {
    agent any
    parameters {
        string(name: 'ADMIN_SERVER_BRANCH', defaultValue: 'main', description: 'Branch for spring-petclinic-admin-server')
        string(name: 'API_GATEWAY_BRANCH', defaultValue: 'main', description: 'Branch for spring-petclinic-api-gateway')
        string(name: 'CONFIG_SERVER_BRANCH', defaultValue: 'main', description: 'Branch for spring-petclinic-config-server')
        string(name: 'CUSTOMERS_SERVICE_BRANCH', defaultValue: 'main', description: 'Branch for spring-petclinic-customers-service')
        string(name: 'DISCOVERY_SERVER_BRANCH', defaultValue: 'main', description: 'Branch for spring-petclinic-discovery-server')
        string(name: 'GENAI_SERVICE_BRANCH', defaultValue: 'main', description: 'Branch for spring-petclinic-genai-service')
        string(name: 'VETS_SERVICE_BRANCH', defaultValue: 'main', description: 'Branch for spring-petclinic-vets-service')
        string(name: 'VISITS_SERVICE_BRANCH', defaultValue: 'main', description: 'Branch for spring-petclinic-visits-service')
    }
    environment {
        DOCKER_HUB_TOKEN = credentials('docker-hub-token')  // Bind as Secret Text (optional for environment)
        DOCKER_HUB_USERNAME = 'vuhoabinhthachhoa'  // Replace with your Docker Hub username
        CHANGED_SERVICES = 'admin-server,api-gateway,config-server,customers-service,discovery-server,genai-service,vets-service,visits-service'  // Example; set dynamically if needed
        IMAGE_TAG = 'latest'  // Example; set dynamically if needed
        HELM_RELEASE_NAME = 'petclinic'
        HELM_CHART = 'spring-petclinic-microservices'
        HELM_REPO_URL = 'https://github.com/OpsInUs/DA02-HelmRepo.git'
        DOCKER_REGISTRY = 'vuhoabinhthachhoa'
    }
    stages {
        stage('Clone Helm Repository') {
            steps {
                sh """
                git clone ${HELM_REPO_URL} DA02-HelmRepo
                """
            }
        }
        stage('Build and Push Docker Images') {
            steps {
                script {
                    def servicesToBuild = env.CHANGED_SERVICES.split(',')
                    
                    withCredentials([string(credentialsId: 'docker-hub-token', variable: 'DOCKER_HUB_TOKEN')]) {
                        sh '''
                            echo "${DOCKER_HUB_TOKEN}" | docker login -u ${DOCKER_HUB_USERNAME} --password-stdin
                        '''
                    }
                    
                    for (service in servicesToBuild) {
                        echo "Building ${service} with tag: ${env.IMAGE_TAG}"
                        buildAndPushService(service)
                    }
                }
            }
        }
        stage('Pull and Deploy Images') {
            steps {
                withCredentials([file(credentialsId: 'kubeconfig', variable: 'KUBECONFIG')]) {
                    script {
                        def services = [
                            'admin-server': params.ADMIN_SERVER_BRANCH,
                            'api-gateway': params.API_GATEWAY_BRANCH,
                            'config-server': params.CONFIG_SERVER_BRANCH,
                            'customers-service': params.CUSTOMERS_SERVICE_BRANCH,
                            'discovery-server': params.DISCOVERY_SERVER_BRANCH,
                            'genai-service': params.GENAI_SERVICE_BRANCH,
                            'vets-service': params.VETS_SERVICE_BRANCH,
                            'visits-service': params.VETS_SERVICE_BRANCH
                        ]
                        def helmSet = ''
                        def updatedServices = []

                        services.each { serviceName, branch ->
                            if (branch != 'main') {
                                def commitHash = sh(script: "git ls-remote https://github.com/spring-petclinic/spring-petclinic-microservices ${branch} | head -1 | cut -f1", returnStdout: true).trim()
                                if (!commitHash) {
                                    error "Branch ${branch} not found for ${serviceName}."
                                }
                                def tag = commitHash.substring(0, 7)
                                def fullImageName = "spring-petclinic-${serviceName}"
                                sh "docker pull ${DOCKER_REGISTRY}/${fullImageName}:${tag}"
                                helmSet += "services.${serviceName}.image.repository=${fullImageName},services.${serviceName}.image.tag=${tag},"
                                updatedServices << serviceName
                            }
                        }

                        if (!helmSet.isEmpty()) {
                            helmSet = helmSet.substring(0, helmSet.length() - 1)
                            helmSet += ",global.namespace=dev-review"
                            sh """
                            helm dependency update DA02-HelmRepo/${HELM_CHART}
                            helm upgrade --install $HELM_RELEASE_NAME DA02-HelmRepo/${HELM_CHART} \
                                --set ${helmSet} \
                                --namespace dev-review \
                                --kubeconfig=\$KUBECONFIG \
                                --kube-context gke_thanh-devops_us-central1-a_petclinic
                            """
                            updatedServices.each { service ->
                                sh """
                                kubectl patch service ${service} -n dev-review --type='json' -p='[{"op": "replace", "path": "/spec/type", "value": "NodePort"}]' --kubeconfig=\$KUBECONFIG
                                """
                            }
                        } else {
                            echo "No services with non-main branches to deploy."
                        }

                        if (!updatedServices.isEmpty()) {
                            echo "Deployment completed. Use the following NodePort endpoints to test:"
                            updatedServices.each { service ->
                                def nodePort = sh(script: "kubectl get service ${service} -n dev-review -o jsonpath='{.spec.ports[0].nodePort}' --kubeconfig=\$KUBECONFIG", returnStdout: true).trim()
                                if (nodePort) {
                                    def nodeIp = sh(script: "kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type==\"ExternalIP\")].address}' --kubeconfig=\$KUBECONFIG", returnStdout: true).trim()
                                    if (!nodeIp) {
                                        nodeIp = sh(script: "kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type==\"InternalIP\")].address}' --kubeconfig=\$KUBECONFIG", returnStdout: true).trim()
                                    }
                                    if (nodeIp) {
                                        echo "Service: ${service} - Endpoint: ${nodeIp}:${nodePort}"
                                    } else {
                                        echo "Service: ${service} - No node IP available. Check GKE node configuration."
                                    }
                                } else {
                                    echo "Service: ${service} - Failed to assign NodePort. Ensure cluster allows dynamic NodePort allocation."
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    post {
        always {
            sh 'docker logout'
        }
    }
}

// Example buildAndPushService function (assuming it's defined elsewhere or needs implementation)
def buildAndPushService(service) {
    sh """
        docker build -t ${DOCKER_REGISTRY}/${service}:${env.IMAGE_TAG} -f Dockerfile.${service} .
        docker push ${DOCKER_REGISTRY}/${service}:${env.IMAGE_TAG}
    """
}
