pipeline {
    agent any
    parameters {
        string(name: 'ADMIN_SERVER_BRANCH', defaultValue: 'main', description: 'Branch for spring-petclinic-admin-server')
        string(name: 'API_GATEWAY_BRANCH', defaultValue: 'main', description: 'Branch for spring-petclinic-api-gateway')
        string(name: 'CONFIG_SERVER_BRANCH', defaultValue: 'main', description: 'Branch for spring-petclinic-config-server')
        string(name: 'CUSTOMERS_SERVICE_BRANCH', defaultValue: 'main', description: 'Branch for spring-petclinic-customers-service')
        string(name: 'DISCOVERY_SERVER_BRANCH', defaultValue: 'main', description: 'Branch for spring-petclinic-discovery-server')
        string(name: 'GENAI_SERVICE_BRANCH', defaultValue: 'main', description: 'Branch for spring-petclinic-genai-service')
        string(name: 'VETS_SERVICE_BRANCH', defaultValue: 'main', description: 'Branch for spring-petclinic-vets-service')
        string(name: 'VISITS_SERVICE_BRANCH', defaultValue: 'main', description: 'Branch for spring-petclinic-visits-service')
    }
    environment {
        HELM_RELEASE_NAME = 'petclinic'
        HELM_CHART_DIR_NAME = 'DA02-HelmRepo'
        HELM_REPO_HTTPS_URL = 'https://github.com/OpsInUs/DA02-HelmRepo.git'
        DOCKER_REGISTRY_USERNAME = 'vuhoabinhthachhoa'
        KUBE_CONTEXT = 'gke_thanh-devops_us-central1-a_petclinic' // Will be used if kubeconfig is explicitly provided
        TARGET_NAMESPACE = 'dev-review'

        // Define your GCP and WIF details
        GCP_PROJECT_ID        = 'thanh-devops'
        GCP_PROJECT_NUMBER    = '321371933596'
        WIF_POOL_ID           = 'jenkins-oidc-pool'
        WIF_PROVIDER_ID       = 'jenkins-provider'
        GCP_SERVICE_ACCOUNT   = 'jenkins-wif-executor-sa@thanh-devops.iam.gserviceaccount.com'
        JENKINS_OIDC_CRED_ID  = 'jenkins-gcp-oidc-token'

        // Construct the Audience for the WIF credential file
        GCP_WIF_AUDIENCE      = "//iam.googleapis.com/projects/${GCP_PROJECT_NUMBER}/locations/global/workloadIdentityPools/${WIF_POOL_ID}/providers/${WIF_PROVIDER_ID}"
    }
    stages {
        stage('Clone Helm Repository via HTTPS') {
            steps {
                checkout([
                    $class: 'GitSCM',
                    branches: [[name: '*/main']],
                    userRemoteConfigs: [[url: HELM_REPO_HTTPS_URL]],
                    extensions: [[$class: 'RelativeTargetDirectory', relativeTargetDir: HELM_CHART_DIR_NAME]]
                ])
            }
        }

        stage('Verify Tools') {
            steps {
                sh 'echo "PATH: $PATH"'
                sh 'which gcloud || echo "gcloud not found"'
                sh 'which git || echo "git not found"'
                sh 'which helm || echo "helm not found"'
                sh 'which docker || echo "docker not found"'
                sh 'which kubectl || echo "kubectl not found"'
                sh 'which gke-gcloud-auth-plugin || echo "gke-gcloud-auth-plugin not found"'
            }
        }

        stage('Authenticate to GCP via Jenkins OIDC and WIF') {
            steps {
                withCredentials([file(variable: 'ID_TOKEN_FILE', credentialsId: JENKINS_OIDC_CRED_ID)]) {
                    script {
                        echo "Jenkins OIDC Token file will be at: ${ID_TOKEN_FILE}"
                        echo "Target GCP Audience for WIF config: ${GCP_WIF_AUDIENCE}"
                        echo "Service Account to impersonate: ${GCP_SERVICE_ACCOUNT}"

                        def wifCredsJson = """
                        {
                          "type": "external_account",
                          "audience": "${GCP_WIF_AUDIENCE}",
                          "subject_token_type": "urn:ietf:params:oauth:token-type:jwt",
                          "token_url": "https://sts.googleapis.com/v1/token",
                          "service_account_impersonation_url": "https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/${GCP_SERVICE_ACCOUNT}:generateAccessToken",
                          "credential_source": {
                            "file": "${ID_TOKEN_FILE}",
                            "format": {
                              "type": "text"
                            }
                          }
                        }
                        """
                        def wifConfigFileInWorkspace = "${WORKSPACE}/gcp_oidc_wif_config.json"
                        writeFile file: wifConfigFileInWorkspace, text: wifCredsJson
                        echo "Generated WIF config file at: ${wifConfigFileInWorkspace}"

                        def tempGcloudConfigDir = "${WORKSPACE}/.gcloud_temp_config_jenkins_oidc"

                        // It's crucial gcloud is in PATH. The Verify Tools stage helps confirm.
                        sh """
                            export CLOUDSDK_CONFIG=${tempGcloudConfigDir}
                            mkdir -p \${CLOUDSDK_CONFIG}
                            echo "Using temporary gcloud config directory: \${CLOUDSDK_CONFIG}"

                            echo "Attempting gcloud login using WIF credential file..."
                            gcloud auth login --brief --cred-file=${wifConfigFileInWorkspace} --quiet

                            echo "--- gcloud auth list (after WIF login) ---"
                            gcloud auth list
                            echo "------------------------------------------"

                            echo "--- gcloud config list (after WIF login) ---"
                            gcloud config list
                            echo "--------------------------------------------"
                            
                            echo "Setting default project for gcloud session to ${GCP_PROJECT_ID}"
                            gcloud config set project ${GCP_PROJECT_ID}

                            echo "Successfully authenticated with GCP using Jenkins OIDC Token and WIF!"
                            echo "Running an example GCP command (listing GKE clusters in project ${GCP_PROJECT_ID})..."
                            gcloud container clusters list --project=${GCP_PROJECT_ID} || echo "Failed to list GKE clusters, but auth might have worked."

                            # No need to rm -f ${wifConfigFileInWorkspace} or rm -rf \${CLOUDSDK_CONFIG} here
                            # Jenkins workspace is cleaned up, and CLOUDSDK_CONFIG is session-specific.
                            # If you want explicit cleanup within the stage, you can add it back.
                        """
                    }
                }
            }
        }
        
        stage('Deploy to Kubernetes') {
            steps {
                // If your kubeconfig (from Jenkins credentials 'kubeconfig') uses gke-gcloud-auth-plugin,
                // the gcloud WIF authentication from the previous stage should be sufficient.
                // You might not need to load the KUBECONFIG file explicitly for auth,
                // but it's still needed for cluster endpoint, CA data etc.
                withCredentials([file(credentialsId: 'kubeconfig', variable: 'KUBECONFIG_FILE_PATH')]) {
                    script {
                        // Set KUBECONFIG environment variable for kubectl and helm to use this specific file
                        // This ensures other settings in your kubeconfig file (like cluster URL, CA data) are used,
                        // while authentication should leverage the gke-gcloud-auth-plugin and the WIF session.
                        env.KUBECONFIG = KUBECONFIG_FILE_PATH 

                        echo "Using Kubeconfig from Jenkins credentials: ${KUBECONFIG_FILE_PATH}"
                        sh 'echo "Kubeconfig content (first 10 lines):"; head -n 10 $KUBECONFIG' // Debug: Check content
                        sh 'kubectl version' // Test kubectl authentication using the WIF session via gke-gcloud-auth-plugin

                        def servicesToUpdate = [
                            'admin-server': params.ADMIN_SERVER_BRANCH,
                            'api-gateway': params.API_GATEWAY_BRANCH,
                            'config-server': params.CONFIG_SERVER_BRANCH,
                            'customers-service': params.CUSTOMERS_SERVICE_BRANCH,
                            'discovery-server': params.DISCOVERY_SERVER_BRANCH,
                            'genai-service': params.GENAI_SERVICE_BRANCH,
                            'vets-service': params.VETS_SERVICE_BRANCH,
                            'visits-service': params.VISITS_SERVICE_BRANCH
                        ]
                        def helmSetArgs = []
                        def servicesWithNodePort = []

                        servicesToUpdate.each { serviceName, branch ->
                            if (branch != 'main') {
                                echo "Processing ${serviceName} with branch ${branch}"
                                
                                def commitHashCmd = "git ls-remote https://github.com/OpsInUs/DA02-CD refs/heads/${branch} | head -1 | cut -f1"
                                def commitHash = sh(script: commitHashCmd, returnStdout: true).trim()

                                if (!commitHash) {
                                    error "Failed to get commit hash for branch '${branch}' for service '${serviceName}'. Branch might not exist or repo is private."
                                }
                                def tag = commitHash.substring(0, 7)
                                def imageName = "spring-petclinic-${serviceName}" 
                                
                                helmSetArgs.add("--set services.${serviceName}.image.repository=${DOCKER_REGISTRY_USERNAME}/${imageName}")
                                helmSetArgs.add("--set services.${serviceName}.image.tag=${tag}")
                                
                                if (serviceName == 'vets-service') { 
                                    helmSetArgs.add("--set services.${serviceName}.serviceType=NodePort")
                                    servicesWithNodePort.add(serviceName)
                                }
                            }
                        }
                        
                        def chartPath = "./${HELM_CHART_DIR_NAME}" 
                        helmSetArgs.add("--set global.namespace=${TARGET_NAMESPACE}")
                        if (helmSetArgs.size() == 1 && helmSetArgs[0] == "--set global.namespace=${TARGET_NAMESPACE}") {
                             echo "No specific service branches provided. Deploying with chart defaults for namespace ${TARGET_NAMESPACE}."
                        }
                        
                        sh "helm dependency update ${chartPath}"

                        // Helm and kubectl should now use the WIF-authenticated gcloud session
                        // if kubeconfig uses gke-gcloud-auth-plugin.
                        // Explicit --kubeconfig and --kube-context might be redundant if KUBECONFIG env var is set
                        // and points to a config using the gke-gcloud-auth-plugin.
                        // However, providing them explicitly ensures clarity if multiple contexts exist.
                        def helmCommand = "helm upgrade --install ${HELM_RELEASE_NAME} ${chartPath} --namespace ${TARGET_NAMESPACE} --kube-context ${KUBE_CONTEXT}"
                        if (!helmSetArgs.isEmpty()) {
                            helmCommand += " " + helmSetArgs.join(" ")
                        }
                        
                        sh helmCommand

                        if (!servicesWithNodePort.isEmpty()) {
                            echo "Deployment completed. For services set to NodePort, use the following endpoints to test:"
                            servicesWithNodePort.each { service ->
                                def servicePortForJsonPath = (service == 'vets-service') ? "8083" : "" 
                                def nodePortJsonPath = ""
                                if (servicePortForJsonPath) {
                                    nodePortJsonPath = "{.spec.ports[?(@.port==${servicePortForJsonPath})].nodePort}"
                                } else {
                                    nodePortJsonPath = "{.spec.ports[0].nodePort}"
                                }

                                // Kubectl commands also use the WIF-authenticated gcloud session
                                def nodePort = sh(script: "kubectl get service ${service} -n ${TARGET_NAMESPACE} -o jsonpath='${nodePortJsonPath}' --context ${KUBE_CONTEXT}", returnStdout: true).trim()
                                if (nodePort) {
                                    def nodeIp = sh(script: "kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type==\"ExternalIP\")].address}' --context ${KUBE_CONTEXT}", returnStdout: true).trim()
                                    if (!nodeIp) {
                                        nodeIp = sh(script: "kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type==\"InternalIP\")].address}' --context ${KUBE_CONTEXT}", returnStdout: true).trim()
                                    }
                                    if (nodeIp) {
                                        echo "Service: ${service} - Endpoint: http://${nodeIp}:${nodePort}"
                                    } else {
                                        echo "Service: ${service} - NodePort ${nodePort}. No node IP available. Check GKE node configuration."
                                    }
                                } else {
                                    echo "Service: ${service} - Failed to get NodePort. Ensure chart sets type to NodePort and cluster allows dynamic NodePort allocation."
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    post {
        always {
            script {
                // Clean up temporary files from WIF stage if they weren't caught by shell script
                // (though CLOUDSDK_CONFIG is session-specific, the wifConfigFileInWorkspace should be cleaned)
                def wifConfigFileInWorkspace = "${WORKSPACE}/gcp_oidc_wif_config.json"
                if (fileExists(wifConfigFileInWorkspace)) {
                    echo "Cleaning up WIF config file: ${wifConfigFileInWorkspace}"
                    sh "rm -f ${wifConfigFileInWorkspace}"
                }
                def tempGcloudConfigDir = "${WORKSPACE}/.gcloud_temp_config_jenkins_oidc"
                 if (fileExists(tempGcloudConfigDir)) { // This check might not work well for directories
                    echo "Cleaning up temporary gcloud config directory: ${tempGcloudConfigDir}"
                    sh "rm -rf ${tempGcloudConfigDir}"
                }
            }
            // Your original Helm chart cleanup
            dir(HELM_CHART_DIR_NAME) { 
                sh "echo 'Cleaning up ${HELM_CHART_DIR_NAME}' && rm -rf ." 
            }
        }
    }
}
